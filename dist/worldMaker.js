/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./tools/worldMaker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/data/items.json":
/*!********************************!*\
  !*** ./assets/data/items.json ***!
  \********************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"0\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"redpowder\\\",\\\"name\\\":\\\"Red powder\\\",\\\"desc\\\":\\\"Crafting material used to brew red potions.\\\"},\\\"1\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"food\\\",\\\"name\\\":\\\"Food\\\",\\\"desc\\\":\\\"Can be used to nourish yourself, boost the productivity of buildings and feed troops.\\\",\\\"effects\\\":{\\\"food\\\":15},\\\"isResource\\\":true,\\\"verb\\\":\\\"Ate\\\"},\\\"2\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"bow\\\",\\\"name\\\":\\\"Bow\\\",\\\"equipment\\\":\\\"rangedw\\\",\\\"range_type\\\":\\\"bow\\\",\\\"ammo\\\":\\\"arrows\\\",\\\"effects\\\":{\\\"acc\\\":20},\\\"recipe\\\":{\\\"7\\\":1,\\\"21\\\":1},\\\"useInBattle\\\":true,\\\"sound\\\":\\\"cloth\\\",\\\"isCrafted\\\":true,\\\"basicRecipe\\\":true},\\\"3\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"timber\\\",\\\"name\\\":\\\"Timber\\\",\\\"desc\\\":\\\"Used to build new buildings.\\\"},\\\"4\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"bomb\\\",\\\"name\\\":\\\"Bomb\\\",\\\"desc\\\":\\\"Explosive usable in battle to harm multiple targets (friends or foes) simultaneously.\\\",\\\"recipe\\\":{\\\"24\\\":3,\\\"35\\\":2},\\\"isWeapon\\\":true,\\\"isCrafted\\\":true,\\\"craftTier\\\":2,\\\"sound\\\":\\\"cloth\\\",\\\"stickMouse\\\":true,\\\"useInBattle\\\":true},\\\"5\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"root\\\",\\\"name\\\":\\\"Sunstreak root\\\",\\\"desc\\\":\\\"Crafting material involved in the brewing of several types of potions. Poisonous if consumed raw.\\\",\\\"isMaterial\\\":true,\\\"effects\\\":{\\\"hp\\\":-50},\\\"yield\\\":2,\\\"bonusYield\\\":1},\\\"6\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"flask\\\",\\\"name\\\":\\\"Dawn\\\",\\\"desc\\\":\\\"Bitter potion, regenerates a lot of health.\\\",\\\"isPotion\\\":true,\\\"recipe\\\":{\\\"17\\\":1,\\\"18\\\":4},\\\"effects\\\":{\\\"hp\\\":100},\\\"useInBattle\\\":true,\\\"isCrafted\\\":true,\\\"craftTier\\\":2,\\\"sound\\\":\\\"alchemy\\\",\\\"basicRecipe\\\":true,\\\"ability\\\":7,\\\"verb\\\":\\\"Drank\\\"},\\\"7\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"wood\\\",\\\"name\\\":\\\"Wood\\\",\\\"envFrames\\\":[\\\"wood\\\"],\\\"desc\\\":\\\"Crafting material used to make wooden weapons or to make charcoal. Can also be used as a melee weapon of fortune.\\\",\\\"sound\\\":\\\"woodsmall\\\",\\\"isMaterial\\\":true,\\\"equipment\\\":\\\"meleew\\\",\\\"effects\\\":{\\\"dmg\\\":2}},\\\"8\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"thickgrass\\\",\\\"name\\\":\\\"Thick Grass\\\",\\\"desc\\\":\\\"Crafting material used to make string.\\\",\\\"sound\\\":\\\"soft\\\",\\\"nbBushes\\\":1,\\\"yield\\\":3,\\\"bonusYield\\\":1,\\\"nbClusters\\\":100,\\\"envFrames\\\":[\\\"bush_5\\\"]},\\\"9\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"hide\\\",\\\"name\\\":\\\"Pelt\\\",\\\"desc\\\":\\\"Crafting material obtained from dead animals. Used to craft several pieces of equipment. Also very valuable to sell to settlements.\\\",\\\"sound\\\":\\\"cloth\\\"},\\\"10\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"tunic\\\",\\\"name\\\":\\\"Tunic\\\",\\\"equipment\\\":\\\"armor\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"43\\\":8},\\\"effects\\\":{\\\"def\\\":4},\\\"sound\\\":\\\"cloth\\\",\\\"basicRecipe\\\":true,\\\"ability\\\":6},\\\"11\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"pirate-sword\\\",\\\"name\\\":\\\"Sword\\\",\\\"equipment\\\":\\\"meleew\\\",\\\"effects\\\":{\\\"dmg\\\":20},\\\"useInBattle\\\":true,\\\"desc\\\":\\\"An adventurer's best friend.\\\",\\\"sound\\\":\\\"sword\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"33\\\":3}},\\\"12\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"gun\\\",\\\"name\\\":\\\"Gun\\\",\\\"equipment\\\":\\\"rangedw\\\",\\\"range_type\\\":\\\"gun\\\",\\\"ammo\\\":\\\"bullets\\\",\\\"effects\\\":{\\\"acc\\\":5},\\\"useInBattle\\\":true,\\\"sound\\\":\\\"equip\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"7\\\":2,\\\"24\\\":2}},\\\"13\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"shield1\\\",\\\"name\\\":\\\"Wooden shield\\\",\\\"effects\\\":{\\\"def\\\":2},\\\"sound\\\":\\\"equip\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"7\\\":10}},\\\"14\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"sunflower\\\",\\\"envFrames\\\":[\\\"bush_3\\\"],\\\"decorFrame\\\":\\\"b4\\\",\\\"name\\\":\\\"Sunstreak\\\",\\\"desc\\\":\\\"Flower with regenerative properties used to brew potions.\\\",\\\"isMaterial\\\":true,\\\"sound\\\":\\\"soft\\\",\\\"nbBushes\\\":2,\\\"yield\\\":2,\\\"bonusYield\\\":1,\\\"coitems\\\":[5],\\\"insect\\\":true,\\\"nbClusters\\\":100},\\\"15\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"boots\\\",\\\"name\\\":\\\"Leather boots\\\",\\\"equipment\\\":\\\"boots\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"43\\\":4}},\\\"16\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"belt\\\",\\\"name\\\":\\\"Leather belt\\\",\\\"equipment\\\":\\\"belt\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"43\\\":1},\\\"ability\\\":6,\\\"slots\\\":2},\\\"17\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"yellowpowder\\\",\\\"name\\\":\\\"Daybreak\\\",\\\"desc\\\":\\\"Alchemical substance used to brew healing potions.\\\",\\\"recipe\\\":{\\\"14\\\":2,\\\"27\\\":1},\\\"isCrafted\\\":true,\\\"craftTier\\\":1,\\\"isMaterial\\\":true,\\\"sound\\\":\\\"powder\\\",\\\"basicRecipe\\\":true},\\\"18\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"clover\\\",\\\"name\\\":\\\"Daydream\\\",\\\"envFrames\\\":[\\\"clovers_1\\\",\\\"clovers_2\\\",\\\"clovers_3\\\"],\\\"desc\\\":\\\"Plant used as alchemical ingredient for brewing health potions.\\\",\\\"isMaterial\\\":true,\\\"sound\\\":\\\"soft\\\",\\\"nbBushes\\\":4,\\\"yield\\\":5,\\\"bonusYield\\\":3,\\\"nbClusters\\\":100},\\\"19\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"quiver\\\",\\\"name\\\":\\\"Small quiver\\\",\\\"equipment\\\":\\\"range_container\\\",\\\"container_type\\\":\\\"arrows\\\",\\\"capacity\\\":10,\\\"desc\\\":\\\"Can contain up to 10 arrows\\\",\\\"useInBattle\\\":true,\\\"sound\\\":\\\"cloth\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"21\\\":1,\\\"43\\\":3},\\\"ability\\\":6,\\\"basicRecipe\\\":true},\\\"20\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"arrow\\\",\\\"name\\\":\\\"Arrow\\\",\\\"equipment\\\":\\\"range_ammo\\\",\\\"container_type\\\":\\\"quiver\\\",\\\"range_type\\\":\\\"bow\\\",\\\"effects\\\":{\\\"dmg\\\":12},\\\"isAmmo\\\":true,\\\"ammo\\\":\\\"quiver\\\",\\\"useInBattle\\\":true,\\\"sound\\\":\\\"woodsmall\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"7\\\":1,\\\"24\\\":1,\\\"30\\\":1},\\\"basicRecipe\\\":true,\\\"output\\\":5},\\\"21\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"string\\\",\\\"name\\\":\\\"String\\\",\\\"desc\\\":\\\"Robust string made from plant fibers, primarily used to make bows.\\\",\\\"isCrafted\\\":true,\\\"isMaterial\\\":true,\\\"recipe\\\":{\\\"8\\\":3},\\\"sound\\\":\\\"cloth\\\",\\\"basicRecipe\\\":true},\\\"22\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"coal\\\",\\\"name\\\":\\\"Coal\\\",\\\"desc\\\":\\\"Crafting material that can be mined or obtained from wood. Can be used to heat furnaces, as an ingredient for antidotes or can be converted into carbon.\\\",\\\"isCrafted\\\":true,\\\"isResource\\\":true,\\\"isMaterial\\\":true,\\\"recipe\\\":{\\\"7\\\":5}},\\\"23\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"carbon\\\",\\\"name\\\":\\\"Carbon\\\",\\\"desc\\\":\\\"Crafting material obtained from coal. In combination with iron, it can be used to make steel.\\\",\\\"isCrafted\\\":true,\\\"isMaterial\\\":true,\\\"recipe\\\":{\\\"22\\\":5},\\\"sound\\\":\\\"clank\\\"},\\\"24\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"iron\\\",\\\"name\\\":\\\"Iron ore\\\",\\\"desc\\\":\\\"Crafting material that can be mined and used to make steel for several items.\\\"},\\\"25\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"rawgold\\\",\\\"name\\\":\\\"Gold ore\\\",\\\"desc\\\":\\\"Precious crafting material that can be mined and is ultimately used to mint coins.\\\"},\\\"26\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"stone\\\",\\\"name\\\":\\\"Stone\\\",\\\"isAmmo\\\":true,\\\"useInBattle\\\":true,\\\"equipment\\\":\\\"range_ammo\\\",\\\"container_type\\\":\\\"misc\\\",\\\"range_type\\\":\\\"hands\\\",\\\"effects\\\":{\\\"dmg\\\":2},\\\"envFrames\\\":[\\\"rock_1\\\",\\\"rock_2\\\",\\\"rock_3\\\"],\\\"collides\\\":true,\\\"desc\\\":\\\"Crafting material used to make primitive weapons.\\\",\\\"sound\\\":\\\"equip\\\"},\\\"27\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"bone\\\",\\\"name\\\":\\\"Bone\\\",\\\"desc\\\":\\\"Crafting material obtained from dead animals used to make primitive weapons.\\\",\\\"sound\\\":\\\"woodsmall\\\"},\\\"28\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"basic_axe\\\",\\\"name\\\":\\\"Stone hatchet\\\",\\\"desc\\\":\\\"Basic weapon of fortune that can be crafted from wood and stone.\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"7\\\":1,\\\"21\\\":1,\\\"26\\\":1},\\\"equipment\\\":\\\"meleew\\\",\\\"effects\\\":{\\\"dmg\\\":10},\\\"useInBattle\\\":true,\\\"sound\\\":\\\"equip\\\",\\\"basicRecipe\\\":true},\\\"29\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"bone_arrow\\\",\\\"name\\\":\\\"Bone arrow\\\",\\\"equipment\\\":\\\"range_ammo\\\",\\\"container_type\\\":\\\"quiver\\\",\\\"range_type\\\":\\\"bow\\\",\\\"effects\\\":{\\\"dmg\\\":6},\\\"isAmmo\\\":true,\\\"ammo\\\":\\\"quiver\\\",\\\"useInBattle\\\":true,\\\"isEquipment\\\":true,\\\"isCrafted\\\":true,\\\"crafTier\\\":1,\\\"output\\\":5,\\\"recipe\\\":{\\\"7\\\":1,\\\"27\\\":1,\\\"30\\\":1},\\\"sound\\\":\\\"woodsmall\\\",\\\"basicRecipe\\\":true},\\\"30\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"feathers\\\",\\\"envFrames\\\":[\\\"feathers\\\"],\\\"name\\\":\\\"Feathers tuft\\\",\\\"desc\\\":\\\"Crafting material used to make arrows.\\\",\\\"isMaterial\\\":true,\\\"sound\\\":\\\"soft\\\"},\\\"31\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"wheat\\\",\\\"name\\\":\\\"Wheat\\\",\\\"desc\\\":\\\"Resource harvested from farms that can be converted into food at a Mill.\\\",\\\"isResource\\\":true},\\\"32\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"iron_ingot\\\",\\\"name\\\":\\\"Iron ingot\\\",\\\"desc\\\":\\\"Intermediate crafting material obtained from iron ore destined to make steel.\\\",\\\"isCrafted\\\":true,\\\"isMaterial\\\":true,\\\"craftTier\\\":1,\\\"recipe\\\":{\\\"24\\\":5},\\\"sound\\\":\\\"clank\\\"},\\\"33\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"steel_ingot\\\",\\\"name\\\":\\\"Steel ingot\\\",\\\"desc\\\":\\\"Intermediate crafting material obtained from iron ingots and carbon and used to forge weapons.\\\",\\\"isCrafted\\\":true,\\\"isMaterial\\\":true,\\\"craftTier\\\":2,\\\"recipe\\\":{\\\"23\\\":1,\\\"32\\\":4},\\\"sound\\\":\\\"clank\\\"},\\\"34\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"sulfur\\\",\\\"name\\\":\\\"Sulfur\\\",\\\"desc\\\":\\\"Crafting material used to make black powder.\\\",\\\"isResource\\\":true,\\\"isMaterial\\\":true},\\\"35\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"blackpowder\\\",\\\"name\\\":\\\"Black powder\\\",\\\"desc\\\":\\\"Crafting material made from coal and sulfur used to make bullets and explosives.\\\",\\\"recipe\\\":{\\\"22\\\":1,\\\"34\\\":1},\\\"isMaterial\\\":true,\\\"isCrafted\\\":true,\\\"craftTier\\\":1,\\\"sound\\\":\\\"powder\\\"},\\\"36\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"stingleaf\\\",\\\"name\\\":\\\"Stingleaf\\\",\\\"desc\\\":\\\"Plant with cleansing properties used to brew potions.\\\",\\\"isMaterial\\\":true},\\\"37\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"whitepetal\\\",\\\"name\\\":\\\"Whitepetal\\\",\\\"desc\\\":\\\"Flower with cleansing properties used to brew potions.\\\",\\\"isMaterial\\\":true,\\\"insect\\\":true},\\\"38\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"gold_ingot\\\",\\\"name\\\":\\\"Gold ingot\\\",\\\"desc\\\":\\\"Precious rafting material obtained from golden ore destined to mint coins.\\\",\\\"isCrafted\\\":true,\\\"isMaterial\\\":true,\\\"craftTier\\\":1,\\\"recipe\\\":{\\\"25\\\":5},\\\"sound\\\":\\\"clank\\\"},\\\"39\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"bullet\\\",\\\"name\\\":\\\"Bullet\\\",\\\"desc\\\":\\\"Ammunition used with firearms\\\",\\\"isCrafted\\\":true,\\\"isMaterial\\\":false,\\\"craftTier\\\":1,\\\"recipe\\\":{\\\"24\\\":1,\\\"35\\\":1},\\\"output\\\":5,\\\"equipment\\\":\\\"range_ammo\\\",\\\"container_type\\\":\\\"bullets\\\",\\\"range_type\\\":\\\"gun\\\",\\\"effects\\\":{\\\"dmg\\\":60},\\\"isAmmo\\\":true,\\\"ammo\\\":\\\"ammo_pouch\\\",\\\"useInBattle\\\":true,\\\"sound\\\":\\\"clank\\\"},\\\"40\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"ammopouch\\\",\\\"name\\\":\\\"Small bullets pouch\\\",\\\"equipment\\\":\\\"range_container\\\",\\\"container_type\\\":\\\"bullets\\\",\\\"capacity\\\":10,\\\"desc\\\":\\\"Can contain up to 10 bullets\\\",\\\"useInBattle\\\":true,\\\"sound\\\":\\\"cloth\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"21\\\":1,\\\"43\\\":2},\\\"ability\\\":6},\\\"41\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"crimsonpowder\\\",\\\"name\\\":\\\"Crimson dust\\\",\\\"desc\\\":\\\"Enhanced gunpowder used to craft advanced explosives and ammunition.\\\",\\\"recipe\\\":{\\\"24\\\":1,\\\"34\\\":1,\\\"35\\\":1},\\\"isMaterial\\\":true,\\\"isCrafted\\\":true,\\\"craftTier\\\":1,\\\"sound\\\":\\\"powder\\\"},\\\"42\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"biggerammopouch\\\",\\\"name\\\":\\\"Normal bullets pouch\\\",\\\"equipment\\\":\\\"range_container\\\",\\\"container_type\\\":\\\"bullets\\\",\\\"capacity\\\":20,\\\"desc\\\":\\\"Can contain up to 20 bullets\\\",\\\"useInBattle\\\":true,\\\"sound\\\":\\\"cloth\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"21\\\":2,\\\"43\\\":4},\\\"ability\\\":6},\\\"43\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"leather\\\",\\\"name\\\":\\\"Leather\\\",\\\"desc\\\":\\\"Crafting material made from pelts used to craft various pieces of equipment.\\\",\\\"isCrafted\\\":true,\\\"isMaterial\\\":true,\\\"recipe\\\":{\\\"9\\\":1},\\\"output\\\":5,\\\"sound\\\":\\\"cloth\\\",\\\"basicRecipe\\\":true},\\\"44\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"bomb2\\\",\\\"name\\\":\\\"Crimson strike\\\",\\\"desc\\\":\\\"Advanced explosive, inflicts much more damage than traditional bombs.\\\",\\\"recipe\\\":{\\\"24\\\":3,\\\"41\\\":2},\\\"isWeapon\\\":true,\\\"isCrafted\\\":true,\\\"craftTier\\\":2,\\\"sound\\\":\\\"cloth\\\",\\\"stickMouse\\\":true,\\\"useInBattle\\\":true},\\\"45\\\":{\\\"atlas\\\":\\\"items\\\",\\\"frame\\\":\\\"stone_arrow\\\",\\\"name\\\":\\\"Stone arrow\\\",\\\"equipment\\\":\\\"range_ammo\\\",\\\"container_type\\\":\\\"quiver\\\",\\\"range_type\\\":\\\"bow\\\",\\\"effects\\\":{\\\"dmg\\\":3},\\\"isAmmo\\\":true,\\\"ammo\\\":\\\"quiver\\\",\\\"useInBattle\\\":true,\\\"isEquipment\\\":true,\\\"isCrafted\\\":true,\\\"crafTier\\\":1,\\\"output\\\":5,\\\"recipe\\\":{\\\"7\\\":1,\\\"26\\\":1,\\\"30\\\":1},\\\"sound\\\":\\\"woodsmall\\\",\\\"basicRecipe\\\":true},\\\"46\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"duskflask\\\",\\\"name\\\":\\\"Dusk\\\",\\\"desc\\\":\\\"Sweet potion, regenerates vigor.\\\",\\\"isPotion\\\":true,\\\"recipe\\\":{\\\"5\\\":1},\\\"effects\\\":{\\\"vigor\\\":30},\\\"useInBattle\\\":true,\\\"isCrafted\\\":true,\\\"craftTier\\\":1,\\\"sound\\\":\\\"alchemy\\\",\\\"basicRecipe\\\":true,\\\"ability\\\":7,\\\"verb\\\":\\\"Drank\\\"},\\\"47\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"berries\\\",\\\"name\\\":\\\"Caor berries\\\",\\\"desc\\\":\\\"Low nutritious value, only usable to nourish oneself a little.\\\",\\\"effects\\\":{\\\"food\\\":2},\\\"isResource\\\":true,\\\"envFrames\\\":[\\\"berriesbush\\\"],\\\"sound\\\":\\\"soft\\\",\\\"nbBushes\\\":4,\\\"yield\\\":5,\\\"bonusYield\\\":3,\\\"verb\\\":\\\"Ate\\\",\\\"insect\\\":true,\\\"decorFrame\\\":\\\"b4\\\",\\\"nbClusters\\\":100},\\\"48\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"fists\\\",\\\"name\\\":\\\"Fists\\\",\\\"desc\\\":\\\"The most basic melee weapon at your disposal. Can't be unequipped.\\\",\\\"sound\\\":\\\"soft\\\",\\\"verb\\\":\\\"Ate\\\",\\\"equipment\\\":\\\"meleew\\\",\\\"isCrafted\\\":false,\\\"permanent\\\":true},\\\"49\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"hands\\\",\\\"name\\\":\\\"Hands\\\",\\\"desc\\\":\\\"The most basic melee weapon at your disposal. Can be used to throw stones and explosives. Can't be unequipped.\\\",\\\"sound\\\":\\\"soft\\\",\\\"equipment\\\":\\\"rangedw\\\",\\\"range_type\\\":\\\"hands\\\",\\\"ammo\\\":\\\"stones\\\",\\\"effects\\\":{\\\"acc\\\":20},\\\"useInBattle\\\":true,\\\"isCrafted\\\":false,\\\"permanent\\\":true},\\\"50\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"shuriken\\\",\\\"name\\\":\\\"Shuriken\\\",\\\"equipment\\\":\\\"range_ammo\\\",\\\"container_type\\\":\\\"misc\\\",\\\"range_type\\\":\\\"hands\\\",\\\"effects\\\":{\\\"dmg\\\":2},\\\"isAmmo\\\":true,\\\"ammo\\\":\\\"quiver\\\",\\\"useInBattle\\\":true,\\\"envFrames\\\":[\\\"rock_1\\\",\\\"rock_2\\\",\\\"rock_3\\\"],\\\"collides\\\":true,\\\"desc\\\":\\\"Ninja stars can be thrown.\\\",\\\"sound\\\":\\\"equip\\\"},\\\"51\\\":{\\\"atlas\\\":\\\"items2\\\",\\\"frame\\\":\\\"ammopouch\\\",\\\"name\\\":\\\"Small projectiles pouch\\\",\\\"equipment\\\":\\\"range_container\\\",\\\"container_type\\\":\\\"misc\\\",\\\"capacity\\\":10,\\\"desc\\\":\\\"Can contain up to 10 projectiles\\\",\\\"useInBattle\\\":true,\\\"sound\\\":\\\"cloth\\\",\\\"isCrafted\\\":true,\\\"recipe\\\":{\\\"21\\\":1,\\\"43\\\":2},\\\"ability\\\":6,\\\"basicRecipe\\\":true}}\");\n\n//# sourceURL=webpack:///./assets/data/items.json?");

/***/ }),

/***/ "./shared/SpaceMap.js":
/*!****************************!*\
  !*** ./shared/SpaceMap.js ***!
  \****************************/
/*! exports provided: SpaceMap, SpaceMapList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpaceMap\", function() { return SpaceMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpaceMapList\", function() { return SpaceMapList; });\n/**\n * Created by Jerome on 23-04-17.\n */\n\n\n// A space map is a custom data struture, similar to a sparse 2D array. Entities are stored according to their coordinates;\n// that is, two keys are needed to fetch entities, the x position and the y position. This allows fast look-up based on position,\n// e.g. var objectAtSomePosition = mySpaceMap.get(x,y);\nfunction SpaceMap(){}\n\nSpaceMap.prototype.add = function(x,y,object){\n    if(!this.hasOwnProperty(x))this[x] = {};\n    if(object === undefined) object = 1;\n    this[x][y] = object; // replaces any existing object\n};\n\nSpaceMap.prototype.accumulate = function(x,y,object,cb){\n    if(!this.hasOwnProperty(x))this[x] = {};\n    if(object === undefined) object = 1;\n    if(this[x][y]){\n        cb.call(this[x][y]);\n    }else{\n        this[x][y] = object;\n    }\n};\n\nSpaceMap.prototype.increment = function(x,y){\n    if(!this.hasOwnProperty(x))this[x] = {};\n    if(!this[x].hasOwnProperty(y)) this[x][y] = 0;\n    this[x][y]++;\n    return this[x][y];\n};\n\n// Works also by calling mySpaceMap[x][y]\nSpaceMap.prototype.get = function(x,y){\n    if(!this.hasOwnProperty(x)) return null;\n    if(!this[x].hasOwnProperty(y)) return null;\n    return this[x][y];\n};\n\nSpaceMap.prototype.has = function(x,y){\n    if(!this.hasOwnProperty(x)) return false;\n    return(this[x].hasOwnProperty(y));\n};\n\nSpaceMap.prototype.delete = function(x,y){\n    if(!this.hasOwnProperty(x)) return;\n    if(!this[x].hasOwnProperty(y)) return;\n    delete this[x][y];\n    if(Object.keys(this[x]).length == 0) delete this[x];\n};\n\nSpaceMap.prototype.getFirst = function(){\n    return this.toList()[0].v;\n};\n\nSpaceMap.prototype.merge = function(otherMap){\n    otherMap.toList().forEach(function(cell){\n        this.add(cell.x,cell.y);\n    },this);\n};\n\nSpaceMap.prototype.toList = function(compact,skipv){ // serialize to a list representation\n    var list = [];\n    for(var x in this){\n        if(this.hasOwnProperty(x)){\n            for(var y in this[x]){\n                if(this[x].hasOwnProperty(y)){\n                    if(compact){\n                        if(skipv){\n                            list.push([parseInt(x), parseInt(y)]);\n                        }else {\n                            list.push([parseInt(x), parseInt(y), this[x][y]]);\n                        }\n                    }else {\n                        if(skipv){\n                            list.push({\n                                x: x,\n                                y: y\n                            });\n                        }else {\n                            list.push({\n                                x: x,\n                                y: y,\n                                v: this[x][y]\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return list;\n};\n\nSpaceMap.prototype.fromList = function(list,compact) { // unserialize from list representation\n    for(var i = 0; i < list.length; i++){\n        var item = list[i];\n        if(compact){\n            this.add(item[0],item[1],(item[2] || {}))\n        }else {\n            this.add(item.x, item.y, (item.v || {}));\n        }\n    }\n};\n\nSpaceMap.prototype.toString = function(){ // serialize to a list representation\n    var s = \"\";\n    for(x in this){\n        if(this.hasOwnProperty(x)){\n            for(y in this[x]){\n                if(this[x].hasOwnProperty(y)) {\n                    s += \"(\"+x+\",\"+y+\",\"+this[x][y]+\")\";\n                }\n            }\n        }\n    }\n    return s;\n};\n\n\n// ###############\n\nfunction SpaceMapList(){}\n\nSpaceMapList.prototype.add = function(x,y,object){\n    if(!this.hasOwnProperty(x))this[x] = {};\n    if(!this[x].hasOwnProperty(y)) this[x][y] = [];\n    if(object === undefined) object = 1;\n    this[x][y].push(object);\n};\n\n// Works also by calling mySpaceMap[x][y]\nSpaceMapList.prototype.get = function(x,y){\n    if(!this.hasOwnProperty(x)) return [];\n    if(!this[x].hasOwnProperty(y)) return [];\n    return this[x][y];\n};\n\nSpaceMapList.prototype.delete = function(x,y,object){\n    if(!this.hasOwnProperty(x)) return;\n    if(!this[x].hasOwnProperty(y)) return;\n    this[x][y].splice(this[x][y].findIndex(function(e){\n        return e.getShortID() == object.getShortID();\n    }),1);\n    if(Object.keys(this[x]).length == 0) delete this[x];\n};\n\n\n\n//# sourceURL=webpack:///./shared/SpaceMap.js?");

/***/ }),

/***/ "./shared/Utils.js":
/*!*************************!*\
  !*** ./shared/Utils.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shared_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/World */ \"./shared/World.js\");\n/* harmony import */ var _assets_data_items_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/data/items.json */ \"./assets/data/items.json\");\nvar _assets_data_items_json__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../assets/data/items.json */ \"./assets/data/items.json\", 1);\n/**\n * Created by Jerome on 11-08-17.\n */\n\n\n\n\n\n\nvar Utils = {\n    colors: {},\n    strokes: {},\n    fonts: {}\n};\n\nUtils.colors.white = '#ffffff';\nUtils.colors.gold = '#ffd700';\nUtils.colors.red = '#ff0000';\nUtils.colors.lightred = '#ff3b3b';\nUtils.colors.blue = '#558fff';\nUtils.strokes.red = '#331111';\nUtils.colors.green = '#11ee11';\n\nUtils.fonts.normal = 'arial';\nUtils.fonts.fancy = 'belwe';\n\n// ### Coordinates methodes ###\n\n/**\n * Return the AOI to which a tile belongs.\n * @param {Object|number} tile - {x,y} coordinates of tile, or alternatively the x coordinate only.\n * @param {number} y - The y coordinate of the tile.\n */\nUtils.tileToAOI = function(tile,y){\n    var tileX,tileY;\n    if(y !== undefined){\n        tileX = tile;\n        tileY = y;\n    }else{\n        tileX = tile.x;\n        tileY = tile.y;\n    }\n    if(!_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal) throw Error('Chunk data not initialized');\n    tileX = Utils.clamp(tileX,0,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldWidth-1);\n    tileY = Utils.clamp(tileY,0,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldHeight-1);\n    var top = Math.floor(tileY/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight);\n    var left = Math.floor(tileX/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth);\n    return (top*_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)+left;\n};\n\nUtils.AOItoTile = function(aoi){\n    if(!_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal) throw Error('Chunk data not initialized');\n    return {\n        x : (aoi%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)*_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth,\n        y : Math.floor(aoi/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)*_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight\n    };\n};\n\nUtils.getAOIcorners = function(aoi){\n    // Returns in order: tl, tr, br, bl\n    var l = [];\n    var o = Utils.AOItoTile(aoi);\n    l.push(o);\n    l.push({x:o.x+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth,y:o.y});\n    l.push({x:o.x+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth,y:o.y+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight});\n    l.push({x:o.x,y:o.y+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight});\n    return l;\n};\n\nUtils.gridToLine = function(x,y,w){\n    return (y*w)+x;\n};\n\nUtils.gridToLineWithOrigin = function(x,y,w){\n    var aoi = Utils.tileToAOI({x:x,y:y});\n    var origin = Utils.AOItoTile(aoi);\n    return Utils.gridToLine(x-origin.x,y-origin.y,w);\n};\n\nUtils.lineToGrid = function(i,w){\n    return {\n        x: i%w,\n        y: Math.floor(i/w)\n    }\n};\n\nUtils.tileToPct = function(x,y){\n    return {\n        x : x / _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldWidth,\n        y : y / _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldHeight\n    }\n};\n\nUtils.pctToTile = function(x,y){\n    return {\n        x : x * _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldWidth,\n        y : y * _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldHeight\n    }\n};\n\nUtils.screenToMap = function(x,y,map){\n    var tlx = map.x - map.displayOriginX; // top left of map\n    var tly = map.y - map.displayOriginY;\n    console.log(x,y,tlx,tly);\n    return {\n        x: x - tlx,\n        y: y - tly\n    }\n};\n\n// ### Quadrant-related methods ###\n\nUtils.AOIcoordinates = function(aoi){\n    return {\n        x : (aoi%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal),\n        y : Math.floor(aoi/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)\n    }\n};\n\nUtils.distanceBetweenAOIs = function(A,B){\n    return Utils.manhattan(Utils.AOIcoordinates(A),Utils.AOIcoordinates(B));\n};\n\nUtils.tileToQuadrant = function(x,y,quadW,quadH){\n    if(!quadW) quadW = 10;\n    if(!quadH) quadH = 10;\n    var aoi = Utils.tileToAOI({x:x,y:y});\n    return Utils.aoiToQuadrant(aoi,quadW,quadH);\n};\n\nUtils.aoiToQuadrant = function(aoi,quadW,quadH){\n    var aoiCoords = Utils.lineToGrid(aoi,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    var nbQuadsHorizontal = Math.ceil(_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal/quadW);\n    var top = Math.floor(aoiCoords.y/quadH);\n    var left = Math.floor(aoiCoords.x/quadW);\n    return (top*nbQuadsHorizontal)+left;\n};\n\nUtils.distanceToPoles = function(x,y,poles){\n    var aoi = Utils.tileToAOI({x:x,y:y});\n    var aoicoord = Utils.lineToGrid(aoi,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    var dists = []; // distances (in aoi) between tile and each pole\n    var sum = 0;\n    for(var i = 0; i < poles.length; i++){\n        var d = Utils.euclidean(\n            aoicoord,\n            Utils.lineToGrid(poles[i],_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)\n        );\n        if(d == 0) d = 0.1;\n        d *= d; // polarizes more\n        sum += d;\n        dists.push(d);\n    }\n    //console.log('distances :', dists, 'sum = ',sum);\n\n    // Revert: d' = sum/d\n    var sumweights = 0;\n    var weights = dists.map(function(d){\n        //var w = (d > 0 ? sum/d : 1);\n        var w = sum/d;\n        sumweights += w;\n        return w;\n    });\n    //console.log('weights :', weights);\n\n    // Normalize: z = d'/sum'\n    var normalized = weights.map(function(w){\n        var w = Math.round((w/sumweights)*10);\n        if(w <= 2) w = 0;\n        return w;\n    });\n    //console.log('normalized :', normalized);\n    return normalized;\n};\n\n\n// ### General methods ###\n\nUtils.listAdjacentAOIs = function(current){\n    if(!_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal){\n        console.log('ERROR : Chunk data not initialized');\n        return [];\n    }\n\n    var AOIs = [];\n    var isAtTop = (current < _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    var isAtBottom = (current > _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lastChunkID - _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    var isAtLeft = (current%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal == 0);\n    var isAtRight = (current%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal == _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal-1);\n    AOIs.push(current);\n    if(!isAtTop) AOIs.push(current - _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    if(!isAtBottom) AOIs.push(current + _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    if(!isAtLeft) AOIs.push(current-1);\n    if(!isAtRight) AOIs.push(current+1);\n    if(!isAtTop && !isAtLeft) AOIs.push(current-1-_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    if(!isAtTop && !isAtRight) AOIs.push(current+1-_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    if(!isAtBottom && !isAtLeft) AOIs.push(current-1+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    if(!isAtBottom && !isAtRight) AOIs.push(current+1+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\n    return AOIs;\n};\n\nUtils.listNeighborsInGrid = function(current,width,height,offset){\n    offset = (offset || 1);\n    var nbh = [current];\n    var isAtTop = (current < width);\n    var isAtBottom = (current > ((width*height)-1) - width);\n    var isAtLeft = (current%width == 0);\n    var isAtRight = (current%width == width-1);\n    if(!isAtTop) nbh.push(current - width);\n    if(!isAtBottom) nbh.push(current + width);\n    if(!isAtLeft) nbh.push(current-(1*offset));\n    if(!isAtRight) nbh.push(current+(1*offset));\n    if(!isAtTop && !isAtLeft) nbh.push(current-(1*offset)-width);\n    if(!isAtTop && !isAtRight) nbh.push(current+(1*offset)-width);\n    if(!isAtBottom && !isAtLeft) nbh.push(current-(1*offset)+width);\n    if(!isAtBottom && !isAtRight) nbh.push(current+(1*offset)+width);\n    return nbh;\n}\n\nUtils.formatMoney = function(nb){\n    return 'coin'+(nb > 1 ? 's' : '');\n};\n\nUtils.euclidean = function(a,b){\n    //console.log('dist between',a,b);\n    return Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y- b.y,2));\n};\n\nUtils.chebyshev = function(A,B){\n    return Math.max(Math.abs(A.x-B.x),Math.abs(A.y-B.y));\n};\n\nUtils.nextTo = function(a,b){\n    a = a.getRect();\n    b = b.getRect();\n    return Utils.overlap(a,b,true);\n};\n\nUtils.overlap = function(a,b,touch){\n    if(touch){ // touching counts as overlapping\n        if(a.x > b.x + b.w || b.x > a.x + a.w) return false;\n        if(a.y > b.y + b.h || b.y > a.y + a.h) return false;\n    }else{\n        if(a.x >= b.x + b.w || b.x >= a.x + a.w) return false;\n        if(a.y >= b.y + b.h || b.y >= a.y + a.h) return false;\n    }\n    return true;\n};\n\nUtils.getBoxCenter = function(box){\n    return {\n        x: box.x + (box.w/2),\n        y: box.y + (box.h/2)\n    }\n};\n\nUtils.boxesDistance = function(a,b){\n    var ca = Utils.getBoxCenter(a);\n    var cb = Utils.getBoxCenter(b);\n    var dx = Math.max(0,Math.abs(ca.x-cb.x) - (a.w/2) - (b.w/2));\n    var dy = Math.max(0,Math.abs(ca.y-cb.y) - (a.h/2) - (b.h/2));\n    //console.warn(dx,dy);\n    return dx+dy;\n};\n\n/*Utils.multiChebcomponent = function(A,B,coord,length){\n    return Math.min(\n        Math.abs(A[coord]-B[coord]),\n        Math.abs(A[coord]+A[length]-B[coord]),\n        Math.abs(A[coord]-(B[coord]+B[length])),\n        Math.abs(A[coord]+A[length]-(B[coord]+B[length]))\n    );\n};\n\n// a & b should be rectangles, i.e. expose x, y, w and h\nUtils.multiTileChebyshev = function(A,B){\n    return Math.max(Utils.multiChebcomponent(A,B,'x','w'),Utils.multiChebcomponent(A,B,'y','h'));\n};*/\n\n// With respect to B\nUtils.relativePosition = function(A,B){\n    return {\n        x: Math.sign(B.x-A.x),\n        y: Math.sign(B.y-A.y)\n    }\n};\n\nUtils.manhattan = function(a,b){\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n};\n\nUtils.multiTileManhattan = function(A,B){\n    var dx = Math.min(\n        Math.abs(A.x-B.x),\n        Math.abs(A.x+A.w-B.x),\n        Math.abs(A.x-(B.x+B.w)),\n        Math.abs(A.x+A.w-(B.x+B.w))\n    );\n    var dy = Math.min(\n        Math.abs(A.y-B.y),\n        Math.abs(A.y+A.h-B.y),\n        Math.abs(A.y-(B.y+B.h)),\n        Math.abs(A.y+A.h-(B.y+B.h))\n    );\n    return Math.abs(dx)+Math.abs(dy);\n};\n\nUtils.getItemMissionData = function(goal, nb){\n    var mission = goal.split(':');\n    var type = mission[0];\n    var item = mission[1];\n    var itemData = _assets_data_items_json__WEBPACK_IMPORTED_MODULE_1__[item];\n    var verb = type == 'craftitem' ? 'Produce' : 'Gather';\n    return {\n        \"type\": \"Economy\",\n        \"regionStatus\": [2],\n        \"name\": verb+\" \"+nb+\" \"+itemData.name,\n        \"desc\": \"Ensure that at least \"+nb+\" \"+itemData.name+\" are available in the region\",\n        \"atlas\": itemData.atlas,\n        \"frame\": itemData.frame,\n        \"count\": goal,\n        \"goal\": nb,\n        \"rewards\": {\n            \"1\": 1, //TODO: conf\n            \"2\": 2\n        }\n    }\n};\n\nUtils.clamp = function(x,min,max){ // restricts a value to a given interval (return the value unchanged if within the interval\n    return Math.max(min, Math.min(x, max));\n};\n\nUtils.randomInt = function(low, high) { // [low, high]\n    high++;\n    return Math.floor(Math.random() * (high - low) + low);\n};\n\nUtils.randomElement = function(arr){\n    return arr[Math.floor(Math.random()*arr.length)];\n};\n\nUtils.randomElementRemoved = function(arr){\n    return arr.splice(Math.floor(Math.random()*arr.length),1)[0];\n};\n\nUtils.randomNorm = function(mean,std){ // Returns a value from a normal distribution\n    return randomZ()*std+mean;\n};\n\nfunction randomZ() { // Box-Muller transform to return a random value from a reduced normal\n    var u = 0, v = 0;\n    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random();\n    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n}\n\nUtils.swapElements = function(arr,b,c){\n    var tmp = arr[b];\n    arr[b] = arr[c];\n    arr[c] = tmp;\n};\n\nUtils.removeElement = function(v,arr){\n    var idx = arr.indexOf(v);\n    if(idx > -1) arr.splice(idx,1);\n};\n\nUtils.insert = function(a1,a2,pos){ // insert array a2 at position pos in array a1\n    a1.splice.apply(a1, [pos, 0].concat(a2));\n};\n\nUtils.shuffle = function(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n};\n\nUtils.indexOfMax = function(arr) {\n    if (arr.length === 0) return -1;\n    var max = arr[0];\n    var maxIndex = 0;\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] > max) {\n            maxIndex = i;\n            max = arr[i];\n        }\n    }\n    return maxIndex;\n};\n\nUtils.printArray = function(arr){\n    console.log(JSON.stringify(arr));\n};\n\nUtils.capitalizeFirstLetter = function(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nfunction coordinatesPairToTile(coords){\n    return {\n        x: Math.floor(coords.x/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileWidth),\n        y: Math.floor(coords.y/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileHeight)\n    }\n}\n\nfunction coordinatesToCell(v,grid){\n    return Math.floor(v/grid);\n}\n\nUtils.computeSpeed = function(angle){ // return unit speed vector given an angle\n    return {\n        x: Math.cos(angle),\n        y: -Math.sin(angle)\n    }\n};\n\nArray.prototype.diff = function(a) { // returns the elements in the array that are not in array a\n    return this.filter(function(i) {return a.indexOf(i) < 0;});\n};\n\nArray.prototype.last = function(){\n    return this[this.length-1];\n};\n\nArray.prototype.rotate = function( n ) {\n    this.unshift.apply( this, this.splice( n, this.length ) );\n    return this;\n};\n\nArray.prototype.previous = function(i){\n    return (i > 0 ? this[i-1] : this.last());\n};\n\nif (typeof Object.assign !== 'function') {\n    // Must be writable: true, enumerable: false, configurable: true\n    Object.defineProperty(Object, \"assign\", {\n        value: function assign(target, varArgs) { // .length of function is 2\n            'use strict';\n            if (target === null || target === undefined) {\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var to = Object(target);\n\n            for (var index = 1; index < arguments.length; index++) {\n                var nextSource = arguments[index];\n\n                if (nextSource !== null && nextSource !== undefined) {\n                    for (var nextKey in nextSource) {\n                        // Avoid bugs when hasOwnProperty is shadowed\n                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                            to[nextKey] = nextSource[nextKey];\n                        }\n                    }\n                }\n            }\n            return to;\n        },\n        writable: true,\n        configurable: true\n    });\n}\n\n// if (onServer) module.exports.Utils = Utils;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Utils);\n\n//# sourceURL=webpack:///./shared/Utils.js?");

/***/ }),

/***/ "./shared/World.js":
/*!*************************!*\
  !*** ./shared/World.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Created by Jerome on 14-10-17.\n */\n\nvar World = {};\n\nWorld.setUp = function(nbHoriz,nbVert,chunkW,chunkH,tileW,tileH){\n    World.nbChunksHorizontal = nbHoriz;\n    World.nbChunksVertical = nbVert;\n    World.chunkWidth = chunkW;\n    World.chunkHeight = chunkH;\n    World.tileWidth = tileW || 32;\n    World.tileHeight = tileH || 32;\n    World.computeProperties();\n};\n\nWorld.readMasterData = function(data){\n    World.setUp(\n        data.nbChunksHoriz,data.nbChunksVert,\n        data.chunkWidth,data.chunkHeight\n    );\n};\n\nWorld.computeProperties = function(){\n    World.worldWidth = World.chunkWidth*World.nbChunksHorizontal;\n    World.worldHeight = World.chunkHeight*World.nbChunksVertical;\n    World.lastChunkID = World.nbChunksHorizontal*World.nbChunksVertical - 1;\n    console.log('Set up world of size '+World.worldWidth+' x '+World.worldHeight);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (World);\n\n//# sourceURL=webpack:///./shared/World.js?");

/***/ }),

/***/ "./tools/Geometry.js":
/*!***************************!*\
  !*** ./tools/Geometry.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Created by Jerome on 03-08-17.\n */\n\nvar onServer = (typeof window === 'undefined');\n\nif(onServer){\n    var Utils = __webpack_require__(/*! ../shared/Utils.js */ \"./shared/Utils.js\").Utils;\n}\n\nvar Geometry = {\n    lastrectID : 0, // running id of generated rects\n    colors : {\n        0: 0xff0000,\n        1: 0x00ff00,\n        2: 0x0000ff,\n        3: 0xffff00\n    }\n};\n\n// Generates a Gaussian cluster of elements (e.g. trees)\nGeometry.cluster = function(x,y){\n    var pts = [];\n    var stdX = document.getElementById('w').value;\n    var stdY = document.getElementById('h').value;\n    var n = document.getElementById('n').value;\n    var exclude = [];\n    for(var i = 0; i < n; i++){\n        var pt = {\n            x: Math.round(randomNorm(x,stdX)),\n            y: Math.round(randomNorm(y,stdY))\n        };\n        if(Geometry.containsPt(exclude,pt)){\n            i--;\n            continue;\n        }\n        pts.push(pt);\n        for(var e = -3; e < 3; e++){\n            exclude.push({x:pt.x+e,y:pt.y});\n        }\n    }\n    printArray(pts);\n    return pts;\n};\n\nGeometry.containsPt = function(pts,pt){\n    for(var i = 0; i < pts.length; i++){\n        if(pts[i].x == pt.x && pts[i].y == pt.y) return true;\n    }\n    return false;\n};\n\nGeometry.makeCorona = function(x,y,w,h){\n    //var height = document.getElementById('w').value;\n    //var width = document.getElementById('h').value;\n    var width = w;\n    var height = h;\n    var start = {\n        x: x,\n        y: y-height\n    };\n    var pts = [start];\n    Geometry.coronaSide(pts,-1,1,pts[pts.length-1],width,height);\n    Geometry.coronaSide(pts,1,1,pts[pts.length-1],width,height);\n    Geometry.coronaSide(pts,1,-1,pts[pts.length-1],width,height);\n    Geometry.coronaSide(pts,-1,-1,pts[pts.length-1],width,height);\n    //printArray(pts);\n    pts.pop();\n    return pts;\n};\n\nGeometry.coronaSide = function(pts,xstep,ystep,pt,width,height){\n    var initW = width;\n    var initH = height;\n    var refDimension = (xstep == ystep ? height : width);\n    var max = Math.ceil(refDimension/2);\n    var nbSegments = Utils.randomInt(2,max);\n    var alt = +(xstep != ystep);\n\n    for(var i = 0; i < nbSegments; i++){\n        var upperLimitW = Math.min(width-(nbSegments-i),Math.ceil(initW/3));\n        var upperLimitH = Math.min(height-(nbSegments-i),Math.ceil(initH/3));\n        var xlength = (i == nbSegments-1 ? width : Utils.randomInt(1,upperLimitW+1));\n        var ylength = (i == nbSegments-1 ? height : Utils.randomInt(1,upperLimitH+1));\n        width-=xlength;\n        height-=ylength;\n\n        pts.push({\n            x: pts[pts.length-1].x + xlength*xstep*alt,\n            y: pts[pts.length-1].y + ylength*ystep*(1-alt)\n        });\n        pts.push({\n            x: pts[pts.length-1].x + xlength*xstep*(1-alt),\n            y: pts[pts.length-1].y + ylength*ystep*alt\n        });\n    }\n};\n\nGeometry.makePxCoords = function(pt){\n    return {\n        x: pt.x * Engine.tileWidth,\n        y: pt.y * Engine.tileHeight\n    }\n};\n\nGeometry.straightLine = function(start,end){\n    if(isNaN(end.x) || isNaN(end.y)) console.log('WARNING: Not numbers!');\n    var tileWidth = 32;\n    var tileHeight = 32;\n    var step = 32;\n    var speed = Geometry.computeSpeedVector(Geometry.computeAngle(start,end,false)); // false: not degrees\n    var tile = {\n        x: start.x,\n        y: start.y\n    };\n    var tmp = {\n        x: start.x*tileWidth,\n        y: start.y*tileHeight\n    };\n    var lastDist = Geometry.euclidean(tile,end);\n    var tiles = [tile];\n    while(tile.x != end.x || tile.y != end.y){\n        tmp.x += speed.x*step;\n        tmp.y += speed.y*step;\n        tile = {\n            x: Math.floor(tmp.x/tileWidth),\n            y: Math.floor(tmp.y/tileHeight)\n        };\n        //console.log(tile);\n        //console.log(tiles[tiles.length-1]);\n        if(tile.x == tiles[tiles.length-1].x && tile.y == tiles[tiles.length-1].y) continue;\n        var newDist = Geometry.euclidean(tile,end);\n        if(newDist > lastDist) break;\n        tiles.push(tile);\n        lastDist = newDist;\n    }\n    return tiles;\n};\n\nGeometry.addCorners = function(tiles){ // Add corners to a straight line to follow tiles grid\n    for(var i = 0; i < tiles.length-1; i++){\n        var t = tiles[i];\n        var next = tiles[i+1];\n        var dx = next.x - t.x;\n        var dy = next.y - t.y;\n        if(Math.abs(dx) + Math.abs(dy) == 1) continue;\n        var p = {x:t.x,y:t.y};\n        if(dx == -1 && dy == 1) p.x--; // BL\n        if(dx == 1 && dy == 1) p.x++; // BR\n        if(dx == -1 && dy == -1) p.x--; // TL\n        if(dx == 1 && dy == -1) p.x++; // TR\n        tiles.splice(i+1,0,p);// insert new point\n        i++;\n    }\n    return tiles;\n};\n\n// Smoothes a shape obtained from a SVG path\nGeometry.forwardSmoothPass = function(tiles){\n    for(var i = 0; i < tiles.length-1; i++){\n        var t = tiles[i];\n        var next = tiles[i+1];\n        var dx = next.x - t.x;\n        var dy = next.y - t.y;\n        if(dx == 1 && dy == 1){ // angle bottom-right\n            tiles.splice(i+1,0,{\n                x: t.x,\n                y: t.y+1\n            });\n            i++;\n        }\n        if(dx == 1 && dy == -1){ // angle top-right\n            tiles.splice(i+1,0,{\n                x: t.x+1,\n                y: t.y\n            });\n            i++;\n        }\n        if(dx == -1 && dy == 1){ // angle bottom-left\n            tiles.splice(i+1,0,{\n                x: t.x,\n                y: t.y+1\n            });\n            i++;\n        }\n        if(dx == -1 && dy == -1){ // angle top-left\n            tiles.splice(i+1,0,{\n                x: t.x-1,\n                y: t.y\n            });\n            i++;\n        }\n        if(dx == 2 && dy == 0){ // horizontal gap\n            tiles.splice(i+1,0,{\n                x: t.x+1,\n                y: t.y\n            });\n            i++;\n        }\n        if(dx == 0 && dy == 2){ // vertical gap\n            tiles.splice(i,1); // simply remove it\n        }\n    }\n    return tiles;\n};\n\nGeometry.backwardSmoothPass = function(tiles){         // Backward loop to remove tiles ; goes clockwise\n    for(var i = tiles.length-1; i >= 0; i--){\n        var t = tiles[i];\n        //var bnf = false; // back and forth between tiles\n        for(var j = 1; j < Math.min(7,tiles.length+1); j++){ // knots & duplicates\n            var idx = i + j;\n            if(idx > tiles.length-1) idx -= tiles.length;\n            var old= tiles[idx];\n            if(t.x == old.x && t.y == old.y) tiles.splice(i+1,j); // remove j points corresponding to size of knot\n            //if(Math.abs(t.y - old.y) > j) bnf = true;\n        }\n        //if(bnf) tiles.splice(i,1);\n    }\n    return tiles;\n};\n\nGeometry.removeFringeTiles = function(tiles,worldWidth,worldHeight){\n    for(var i = 0; i < tiles.length; i++){\n        var tile = tiles[i];\n        //if(tile.x == 0 || tile.x == worldWidth || tile.y == 0 || tile.y == worldHeight) count++;\n        if(tile.x == 0) tile.x = -1;\n        if(tile.y == 0) tile.y = -1;\n        if(tile.x == worldWidth) tile.x++;\n        if(tile.y == worldHeight) tile.y++;\n    }\n    return tiles;\n};\n\nGeometry.makePoint = function(x,y){\n    return new PIXI.Point(x*Engine.tileWidth,y*Engine.tileHeight);\n};\n\nGeometry.makePolyrect = function(worldx,worldy){\n    var N = 1; // test with n = 5;\n    var rects = [];\n    Geometry.randomRects(rects,worldx,worldy,N,true);\n    var pts = Geometry.mergeRects(rects);\n    var centroid = Geometry.computeCentroid(pts);\n    //Engine.drawCircle(centroid.x,centroid.y,3,0x000000);\n    Geometry.sortPoints(pts,centroid);\n    //Engine.drawCircle(pts[0].x,pts[0].y,4,0xff00ff);\n    Geometry.smoothShape(pts);\n    Geometry.smoothShape(pts); // two passes\n    return pts;\n};\n\nGeometry.randomRects = function(rects,worldx,worldy,N,randomRects){\n    if(randomRects) {\n        for (var i = 0; i < N; i++) {\n            /*var x = (worldx + randomInt(-5, 6)) * Engine.tileWidth;\n            var y = (worldy + randomInt(-5, 6)) * Engine.tileHeight;\n            var w = randomInt(3, 10) * Engine.tileWidth;\n            var h = randomInt(3, 10) * Engine.tileHeight;*/\n            var x = (worldx + randomInt(-5, 6));\n            var y = (worldy + randomInt(-5, 6));\n            var w = randomInt(3, 10);\n            var h = randomInt(3, 10);\n            rects.push(new Rect(x, y, w, h));\n            //console.log(JSON.stringify(rects[rects.length - 1]));\n        }\n    }else {\n        var rectID = 3;\n        switch(rectID){\n            case 0:\n                rects.push(new Rect(worldx * 32, worldy * 32, 128, 256));\n                rects.push(new Rect((worldx * 32) - 192, (worldy * 32) + 128, 192, 128));\n                rects.push(new Rect((worldx * 32) + 128, (worldy * 32) + 128, 192, 288));\n                break;\n            case 1:\n                rects.push(new Rect(1024,288+64,288,288));\n                rects.push(new Rect(992,448+64,224,96));\n                rects.push(new Rect(1056,288+64, 192, 256));\n                break;\n            case 2:\n                rects.push(new Rect(1024,512+64,224,288));\n                rects.push(new Rect(1088,320+64,160,128));\n                rects.push(new Rect(832,352+64,128,160));\n                break;\n            case 3:\n                rects.push(new Rect(800,320+416,160,192));\n                rects.push(new Rect(1088,320+416,224,224));\n                rects.push(new Rect(896,384+416,288,224));\n                break;\n            case 4:\n                rects.push(new Rect(928-64,416,160,192));\n                rects.push(new Rect(1056-64,448,96,256));\n                rects.push(new Rect(1056-64 ,640,192,256));\n                break;\n            case 5:\n                rects.push(new Rect(1088,384,256,288));\n                rects.push(new Rect(1024,576,128,288));\n                rects.push(new Rect(1088,288,192,128));\n                break;\n        }\n    }\n};\n\n// Given a list of rectangles, remove the vertices that are located within other rectangles, compute intersections and\n// return a single shape (as a list of vertices)\nGeometry.mergeRects = function(rects){\n    var queue = [];\n    var pts = [];\n    // Merge the vertices of all rects in a single list\n    for(var i = 0; i < rects.length; i++){\n        queue = queue.concat(rects[i].points);\n    }\n    while(queue.length > 0){\n        var overlap = false;\n        var pt = queue.shift();\n        for(var i = 0; i < rects.length; i++){\n            var rect = rects[i];\n            if(pt.rectID == rect.id) continue;\n            if(rect.contains(pt)){\n                overlap = true;\n                queue = queue.concat(rect.findIntersects(rect));\n                break;\n            }\n        }\n        if(!overlap) pts.push(pt);\n    }\n    return Geometry.removeDuplicates(pts);\n};\n\n// Remove duplicate vertices having arised from merging rectangles\nGeometry.removeDuplicates = function(pts){\n    return pts.reduce(function (p, c) {\n        // create an identifying id from the object values\n        var id = [c.x, c.y].join('|');\n        // if the id is not found in the temp array\n        // add the object to the output array\n        // and add the key to the temp array\n        if (p.temp.indexOf(id) === -1) {\n            p.out.push(c);\n            p.temp.push(id);\n        }\n        return p;\n        // return the deduped array\n    }, { temp: [], out: [] }).out;\n};\n\nGeometry.computeCentroid = function(pts){\n    var sumx = 0;\n    var sumy = 0;\n    for(var i = 0; i < pts.length; i++){\n        sumx += pts[i].x;\n        sumy += pts[i].y;\n    }\n    sumx = sumx/pts.length;\n    sumy = sumy/pts.length;\n    return new PIXI.Point(sumx,sumy);\n};\n\nGeometry.sortPoints = function(pts,centroid){\n    for(var i = 0; i < pts.length;i++){\n        pts[i].x -= centroid.x;\n        pts[i].y -= centroid.y;\n    }\n    pts.sort(Geometry.sortAngle);\n    for(var i = 0; i < pts.length;i++){\n        pts[i].x += centroid.x;\n        pts[i].y += centroid.y;\n    }\n};\n\n// Sort points in anti-clockwise order\nGeometry.sortAngle = function(a,b){\n    var origin = {x:0,y:0};\n    var aa = Geometry.computeAngle(a, origin,true);\n    var bb = Geometry.computeAngle(b, origin,true);\n    if(aa > bb) return 1;\n    if(aa < bb) return -1;\n    // If ame angle, sort based on proxiity\n    var ea = Geometry.euclidean(a,origin);\n    var eb = Geometry.euclidean(b,origin);\n    var sign = aa/Math.abs(aa);\n    if(aa == -90) sign = 1;\n    if(aa == 0) sign = -1;\n    if(ea > eb) return 1*sign;\n    if(ea < eb) return -1*sign;\n    return 0;\n};\n\nGeometry.smoothShape = function(pts){\n    for(var i = 0; i < pts.length; i++){\n        var b = (i+1 < pts.length ? i+1 : i+1-pts.length);\n        var c = (i+2 < pts.length ? i+2 : i+2-pts.length);\n        var d = (i+3 < pts.length ? i+3 : i+3-pts.length);\n        var angle = Geometry.computeAngle(pts[i],pts[b],true);\n        var angle2 = Geometry.computeAngle(pts[i],pts[c],true);\n        if(angle == angle2){ // straight line, remove intermediate point\n            pts.splice(b,1);\n        }else if((angle%45 != 0 && angle2%45 == 0)) { // swap to points\n            swapElements(pts,b,c);\n        }else if(angle%90 == 0 && angle2%90 == 0 && angle != angle2){ // swap to points to remove triangle\n            swapElements(pts,c,d);\n        }else if(angle%45 == 0 && angle2%90 == 0 && angle != angle2){ // swap two points to remove spike\n            swapElements(pts,b,c);\n        }else if((angle%45 != 0 && angle2%45 != 0)) { // create an angle\n            pts.splice(b,0,new PIXI.Point(pts[i].x,pts[b].y));\n        }\n    }\n};\n\n// Create the points corresponding to tiles between vertices of a shape\nGeometry.interpolatePoints = function(pts){\n    for(var i = 0; i < pts.length; i++) {\n        var next = (i == pts.length - 1 ? 0 : i + 1);\n        var dx = (pts[next].x - pts[i].x);\n        var dy = (pts[next].y - pts[i].y);\n        // j used for positioning new points, k for counting them and managing position in array\n        for(var j = 1, k = 1; j < Math.max(Math.abs(dx),Math.abs(dy)); j++, k++){\n            pts.splice(i+k,0,{\n                x: pts[i].x + (j*(dx/Math.abs(dx)) || 0),\n                y: pts[i].y + (j*(dy/Math.abs(dy)) || 0)\n            });// insert new point\n        }\n        i += k-1;\n    }\n    return pts;\n};\n\nGeometry.euclidean = function(a,b){\n    return Math.pow(a.x-b.x,2)+Math.pow(a.y- b.y,2);\n};\n\nGeometry.manhattan = function(a,b){\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n};\n\nGeometry.computeAngle = function(a,b,degrees){ // return angle between points a and b\n    var angle = -(Math.atan2(b.y- a.y, b.x- a.x));\n    if(degrees) { // returns in degrees instead\n        angle *= (180/Math.PI);\n        if(angle == -180) angle*= -1;\n    }\n    return angle;\n};\n\nGeometry.computeSpeedVector = function(angle){ // return unit speed vector given an angle\n    return {\n        x: Math.cos(angle),\n        y: -Math.sin(angle)\n    }\n};\n\n// Rects to polygon code (legacy from fog of war)\n\nfunction Pt(x,y){\n    this.x = x;\n    this.y = y;\n    this.c = 1; // count\n    this.nbors = [];\n}\n\nPt.prototype.link = function(pt){\n    this.nbors.push(pt);\n};\n\nPt.prototype.unlink = function(pt){\n    var idx = this.nbors.findIndex(function(e){\n        return (e.x == pt.x && e.y == pt.y);\n    });\n    this.nbors.splice(idx,1);\n};\n\nPt.prototype.equal = function(pt){\n    if(pt === null) return false;\n    return (this.x == pt.x && this.y == pt.y);\n};\n\nPt.prototype.ts = function(){\n    return \"(\"+this.x+\",\"+this.y+\")\";\n};\n\nPt.prototype.debug = function(){\n    console.log(this.ts(),\"has\",this.nbors.length,\"neighbors and a count of\",this.c);\n};\n\nfunction link(pts){ // link together all points in list\n    for(var i = 0; i < pts.length; i++){\n        for(var j = i; j < pts.length; j++){\n            var a = pts[i];\n            var b = pts[j];\n            var dx = Math.abs(a.x-b.x);\n            var dy = Math.abs(a.y-b.y);\n            if( dx ? !dy : dy ) { // xor, equivalent to avoiding diagonals\n                //console.log(\"Linking\",a.ts(),\"to\",b.ts());\n                a.link(b);\n                b.link(a);\n            }\n        }\n    }\n}\n\nfunction unlink(pt){ // unlink a point from all its neighbors\n    pt.nbors.forEach(function(nb){\n        nb.unlink(pt);\n    });\n}\n\nfunction lint(pts){ // remove side-by-side duplicate neighbors\n    for(var i = pts.length-2; i >= 0; i--){\n        if(i == pts.length-1) continue; // needed when there are 4 duplicates in a row\n        if(pts[i].equal(pts[i+1])){\n            pts.splice(i+1,1);\n            pts.splice(i,1);\n        }\n    }\n}\n\nfunction rectsToPoly(aois){\n    var space = new SpaceMap();\n    aois.forEach(function(aoi){\n        var corners = Utils.getAOIcorners(aoi);\n        var pts = [];\n        corners.forEach(function(corner){\n            var pt = space.get(corner.x,corner.y);\n            if(pt){\n                pt.c++;\n            }else{\n                pt = new Pt(corner.x,corner.y);\n                space.add(pt.x,pt.y,pt);\n            }\n            pts.push(pt);\n        });\n        link(pts);\n    });\n\n    /*space.toList().forEach(function(pt){\n        pt.v.debug();\n    });*/\n\n    space.toList().forEach(function(entry){\n        var pt = entry.v;\n        if(pt.c%2 == 0){ // redundant points have the property of having even counts\n            unlink(pt);\n            link(pt.nbors);\n            space.delete(pt.x,pt.y);\n        }\n    });\n\n    var l = space.toList();\n    l.forEach(function(entry){\n        var pt = entry.v;\n        lint(pt.nbors);\n    });\n\n    var s = space.getFirst();\n    var path = [s];\n    var i = 0;\n    while(true){\n        if(i > 10000) break; //TODO: remove\n        var pt = path[0];\n        var pv = null;\n        if(path.length > 1) pv = path[1];\n        var nt = null;\n        for(var j = 0; j < pt.nbors.length; j++){ // Find next neighbor to travel to\n            var nb = pt.nbors[j];\n            if(!nb.equal(pv)){\n                nt = nb;\n                break;\n            }\n        }\n        //if(nt === null) console.warn('no next for pt',pt.x,pt.y);\n        if(nt.equal(s)) break;\n        path.unshift(nt);\n        i++;\n    }\n\n    return path;\n}\n\n\nif (onServer) module.exports.Geometry = Geometry;\n\n//# sourceURL=webpack:///./tools/Geometry.js?");

/***/ }),

/***/ "./tools/autopath.js":
/*!***************************!*\
  !*** ./tools/autopath.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Created by Jerome Renaux (jerome.renaux@gmail.com) on 23-01-19.\n */\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar Jimp = __webpack_require__(/*! jimp */ \"jimp\");\nvar SpaceMap = __webpack_require__(/*! ../shared/SpaceMap.js */ \"./shared/SpaceMap.js\").SpaceMap;\nvar Geometry = __webpack_require__(/*! ./Geometry.js */ \"./tools/Geometry.js\").Geometry;\n\nfunction Px(x,y){\n    this.x = x;\n    this.y = y;\n}\n\nPx.prototype.neighbors = function*(skipDiag){\n    for(var i = 0; i < contour.length; i++) {\n        var c = {x: contour[i][0], y: contour[i][1]};\n        if(skipDiag && c.x != 0 && c.y != 0) continue;\n        yield {x:this.x + c.x,y:this.y + c.y};\n    }\n};\n\nPx.prototype.clockwiseMoore = function*(image,sdir) {\n    var moore = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\n    var idx = moore.findIndex(function(e){\n        return (e[0] == sdir[0] && e[1] == sdir[1]);\n    });\n    if(idx == -1) console.warn('WARNING: direction not found');\n    moore = moore.rotate(idx+1);\n    for(var i = 0; i < moore.length; i++){\n        var c = {x:moore[i][0],y:moore[i][1]};\n        var p = {x:this.x+c.x,y:this.y+c.y};\n        if(p.x < 0 || p.y < 0 || p.x >= image.bitmap.width || p.y >= image.bitmap.height) continue;\n        var c_ = {x:moore.previous(i)[0],y:moore.previous(i)[1]};\n        var p_ = {x:this.x+c_.x,y:this.y+c_.y};\n        var dir = [p.x-p_.x,p.y-p_.y];\n        yield {p:new Px(p.x,p.y),dir:dir};\n    }\n};\n\nPx.prototype.getFirstWhiteNbr = function(image){\n    for(var nbr of this.neighbors(true)){\n        if(nbr.x < 0 || nbr.y < 0 || nbr.x >= image.bitmap.width || nbr.y >= image.bitmap.height) continue;\n        if(image.getPixelColor(nbr.x, nbr.y) == 4294967295) return new Px(nbr.x,nbr.y);\n    }\n    return null;\n};\n\nPx.prototype.toList = function(){\n    return [this.x,this.y];\n};\n\nvar contour = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\nvar explored = new SpaceMap();\n\nfunction isBlack(image,x,y){\n    return (image.getPixelColor(x, y) != 4294967295) // == 255;\n}\n\nfunction isWhite(image,x,y){\n    return (image.getPixelColor(x, y) == 4294967295);\n}\n\nfunction isExplored(x,y){\n    return explored.has(x,y);\n}\n\nfunction hasWhiteNb(image,x,y,diags){\n    for(var i = 0; i < contour.length; i++){\n        var c = {x:contour[i][0],y:contour[i][1]};\n        if(!diags && Math.abs(c.x + c.y) != 1) continue; // skip diagonals\n        // console.log(x+c.x,y+c.y,image.getPixelColor(x+c.x, y+c.y));\n        if(isWhite(image,x+c.x, y+c.y)) return true;\n    }\n    return false;\n}\n\nfunction readImage(blueprint,cb){\n    Jimp.read(path.join('tools','blueprints',blueprint), function (err, image) {\n        if (err) throw err;\n        cb(image);\n    });\n}\n\nfunction getContours(image) {\n    console.log('Getting contour ...');\n    // console.trace();\n    var lines = [];\n    for (var x = 0; x < image.bitmap.width; x++) {\n        for (var y = 0; y < image.bitmap.height; y++) {\n            if (isBlack(image, x, y) && hasWhiteNb(image, x, y,false) && !isExplored(x, y)) {\n                // console.warn('starting at',x,y);\n                var path = trace(image, x, y);\n                // console.log(path);\n                if (path && path.length > 2)lines.push(getSegments(path));\n            }\n        }\n    }\n    return lines;\n}\n\nfunction trace(image,x,y){\n    // Travel along neighbors until meeting start node or image boundaries\n    //http://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/moore.html    explored.add(x,y);\n    var B = []; // boundary\n    var s = new Px(x,y); // start\n    B.push([x,y]);\n    var p = new Px(x,y); //current boundary pixel\n    var on = p.getFirstWhiteNbr(image); // backtracked white px from p\n    // console.log('now on',on);\n    // var dir = {x:on.x-p.x,y:on.y-p.y};\n    var dir = [on.x-p.x,on.y-p.y];\n    var stop = false;\n    while(true){\n        // console.log('Swiping around',p,'from dir',dir);\n        var exhausted = true;\n        for(var step of p.clockwiseMoore(image,dir)){\n            on.x = step.p.x;\n            on.y = step.p.y;\n            // if(isExplored(on.x,on.y)) return [];\n            // console.log('now on',on);\n            // TODO: Jacob's stopping criterion?\n            if(isBlack(image,on.x,on.y)){\n                if(isNaN(step.dir[0]) || isNaN(step.dir[1])) console.warn('WARNING: NaN direction');\n                // console.log(on,'is black, entered from',step.dir);\n                B.push([on.x,on.y]);\n                explored.add(on.x,on.y);\n                p = new Px(on.x,on.y);\n                // dir = step.dir;\n                dir[0] = (step.dir[0] == 0 ? 0 : -step.dir[0]);\n                dir[1] = (step.dir[1] == 0 ? 0 : -step.dir[1]);\n                exhausted = false;\n                if(on.x == x && on.y == y) stop = true;\n                break;\n            }\n        }\n        if(stop || exhausted) break;\n    }\n    // console.log(B);\n    return B;\n}\n\n/*function addLine(c,p,lines){\n    var q = new Px(p.x,p.y);\n    // if(q.x > c.x) q.x++;\n    // if(q.y > c.y) q.y++;\n    // lines.push([c,q]);\n    lines.push(q.toList());\n}*/\n\nfunction getSegments(path){\n    var c = path[0];\n    var lines = [c];\n    var bearing = undefined;\n    for(var i = 0; i < path.length; i++){\n        var p = path[i];\n        if(p[0] == c[0] && p[1] == c[1]) continue;\n        var dir = Geometry.computeAngle({x:p[0],y:p[1]},{x:c[0],y:c[1]});\n        if(bearing == undefined) bearing = dir;\n        // console.log(p,c,dir,bearing);\n        if(bearing != dir){\n            // addLine(c,path[i-1],lines);\n            lines.push(path[i-1]);\n            c = path[i-1];\n            bearing = undefined;\n            i--;\n        }\n    }\n    //addLine(c,path[path.length-1],lines);\n    lines.push(path.last());\n    // console.log(lines);\n    return lines;\n}\n\n// readImage('test.png').then(getContours);\n\nmodule.exports.getContours = getContours;\nmodule.exports.readImage = readImage;\n\n\n\n//# sourceURL=webpack:///./tools/autopath.js?");

/***/ }),

/***/ "./tools/worldMaker.js":
/*!*****************************!*\
  !*** ./tools/worldMaker.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shared_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/Utils */ \"./shared/Utils.js\");\n/* harmony import */ var _shared_World__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/World */ \"./shared/World.js\");\n/**\n * Created by Jerome Renaux (jerome.renaux@gmail.com) on 16-12-18.\n */\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar Jimp = __webpack_require__(/*! jimp */ \"jimp\");\nvar rwc = __webpack_require__(/*! random-weighted-choice */ \"random-weighted-choice\");\nvar quickselect = __webpack_require__(/*! quickselect */ \"quickselect\");\n\nvar SpaceMap = __webpack_require__(/*! ../shared/SpaceMap.js */ \"./shared/SpaceMap.js\").SpaceMap;\nvar Geometry = __webpack_require__(/*! ./Geometry.js */ \"./tools/Geometry.js\").Geometry;\nvar autopath = __webpack_require__(/*! ./autopath */ \"./tools/autopath.js\");\n\n\n\n\nvar counter = 0;\nvar total = 0;\n\nfunction Chunk(id){\n    this.id = id;\n    var origin = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].AOItoTile(this.id);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.defaultTile = 'grass';\n    this.layers = [new SpaceMap()];\n    this.decor = [];\n    this.wood = new SpaceMap();\n}\n\nChunk.prototype.addDecor = function(x,y,v){\n    this.decor.push([x,y,v]);\n};\n\nChunk.prototype.addResource = function(x,y,r){\n    if(r == 'wood') this.wood.add(x,y);\n};\n\nChunk.prototype.add = function(x,y,v){ // Add tile\n    this.layers[0].add(x,y,v);\n};\n\nChunk.prototype.remove = function(x,y,v){\n    this.layers[0].delete(x,y);\n};\n\nChunk.prototype.get = function(x,y){\n    return this.layers[0].get(x,y);\n};\n\nChunk.prototype.trim = function(){\n    var layers = [];\n    this.layers.forEach(function(layer){\n       layers.push(layer.toList(true)); // true = compact list\n    });\n    return {\n        id: this.id,\n        x: this.x,\n        y: this.y,\n        default: this.defaultTile,\n        layers: layers,\n        decor: this.decor,\n        wood: this.wood.toList(true)\n    };\n};\n\nChunk.prototype.write = function(chunkpath){\n    var name = 'chunk'+this.id+'.json';\n    fs.writeFile(path.join(chunkpath,name),JSON.stringify(this.trim()),function(err){\n        if(err) throw err;\n        counter++;\n        if(counter == total) console.log(counter+' files written');\n    });\n};\n\nfunction WorldMaker(args){\n    this.outdir = '';\n    this.chunks = {};\n    this.coasts = [];\n\n    this.land = new SpaceMap();\n    this.collisions = new SpaceMap();\n    this.collisionsDebug = new SpaceMap();\n    this.items = new SpaceMap();\n    this.animals = new SpaceMap();\n    this.mapPixels = new SpaceMap();\n\n    this.tileset = null;\n    this.patterns = null;\n\n    this.nbHoriz = args.nbhoriz;\n    this.nbVert = args.nbvert;\n    this.chunkWidth = args.chunkw || 30;\n    this.chunkHeight = args.chunkh || 20;\n    this.tileWidth = args.tilew || 32;\n    this.tileHeight = args.tileh || 32;\n    this.blueprint = args.blueprint;\n\n    this.treeSource = args.treesource;\n    this.notreesave = args.notreesave;\n}\n\nWorldMaker.prototype.addCollision = function(x,y,source){\n    this.collisions.add(x,y,1);\n    this.collisionsDebug.add(x,y,source);\n};\n\nWorldMaker.prototype.run = function(){\n    if(!this.nbHoriz || !this.nbVert){\n        console.log('ERROR : Invalid arguments');\n        console.log('--nbhoriz : number of chunks horizontally (> 0)');\n        console.log('--nbvert : number of chunks vertically (> 0)');\n        console.log('(--chunkw : width of chunks in tiles, default '+defChunkW+')');\n        console.log('(--chunkh : height of chunks in tiles, default '+defChunkH+')');\n        console.log('(--tilew : width of tiles in px, default '+defTileW+')');\n        console.log('(--tileh : height of tiles in px, default '+defTileH+')');\n        return;\n    }\n\n    this.tileset = JSON.parse(fs.readFileSync(path.join(__dirname,'..','assets','tilesets','tileset.json')).toString());\n    this.patterns = JSON.parse(fs.readFileSync(path.join('tools','patterns.json')).toString());\n    var dataAssets = path.join(__dirname,'..','assets','data');\n    this.itemsData = JSON.parse(fs.readFileSync(path.join(dataAssets,'items.json')).toString());\n    this.animalsData = JSON.parse(fs.readFileSync(path.join(dataAssets,'animals.json')).toString());\n\n    this.outdir = path.join(__dirname,'..','maps'); // TODO: remove dev.mapsPath etc?\n    console.log('Writing to',this.outdir);\n\n    if(!fs.existsSync(this.outdir)) fs.mkdirSync(this.outdir);\n    var content = fs.readdirSync(this.outdir);\n    if (content.length > 0 ){\n        console.warn('Deleting existing world');\n        for(var i = 0; i < content.length; i++){\n            fs.unlinkSync(path.join(this.outdir,content[i]));\n        }\n    }\n\n    _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.nbHoriz,this.nbVert,this.chunkWidth,this.chunkHeight,this.tileWidth,this.tileHeight);\n\n    var total = this.nbHoriz*this.nbVert;\n    for(var i = 0; i < total; i++){\n        this.chunks[i] = new Chunk(i);\n    }\n    console.log(total+' chunks created ('+this.nbHoriz+' x '+this.nbVert+')');\n\n    /*this.steps = {\n        'shape_world': this.shapeWorld, // Puts 'c' tiles on contours\n    }\n    this.stepsNames = this.steps.keys();\n    this.step = -1;*/\n\n    autopath.readImage(this.blueprint,this.storeImage.bind(this));\n};\n\n/*WorldMaker.prototype.proceed = function(){\n    if(++this.step >= this.stepsNames.length) return;\n    this.stepsNames\n};*/\n\nWorldMaker.prototype.storeImage = function(image){\n    this.image = image;\n    this.create();\n};\n\nWorldMaker.prototype.create = function(){\n    /*\n    * README:\n    * - Shores are first populated with 'c' tiles based on blueprint (shapeWorld)\n    * - Then the seas are filled, using 'c' tiles as stop tiles (createLakes)\n    * - Then the shores are actually drawn, replacing 'c' based on neighbors (drawShore)\n    * - Then forests are added (createForests)\n    * */\n    var contours = autopath.getContours(this.image);\n    this.shapeWorld(contours);\n    this.collectPixels();\n    this.createLakes();\n    this.drawShore();\n    this.createForests();\n    this.addMisc();\n    this.makeSpawnZones();\n\n    for(var id in this.chunks){\n        this.chunks[id].write(this.outdir);\n    }\n\n    this.writeDataFiles();\n    this.makeWorldmap();\n};\n\nWorldMaker.prototype.shapeWorld = function(contours){\n    // console.log(contours)\n    for(var i = 0; i < contours.length; i++) {\n        var lines = contours[i];\n        var nbPts = lines.length;\n        //console.log('processing curve '+i+' of length '+nbPts);\n        var tiles = [];\n        for (var j = 0; j < nbPts - 1; j++) {\n            var s = lines[j];\n            var e = lines[j+1];\n            s = this.pixelToTile({x:s[0],y:s[1]});\n            e = this.pixelToTile({x:e[0],y:e[1]});\n            var addTiles = Geometry.addCorners(Geometry.straightLine(s, e));\n            if (j > 0) addTiles.shift();\n            tiles = tiles.concat(addTiles);\n        }\n        tiles = Geometry.forwardSmoothPass(tiles);\n        tiles = Geometry.backwardSmoothPass(tiles);\n        if(tiles.length > 1) this.addCoastTiles(tiles);\n    }\n};\n\nWorldMaker.prototype.isBusy = function(node){\n    if(!isInWorldBounds(node.x,node.y)) return true;\n    return this.collisions.has(node.x,node.y);\n};\n\nfunction isInWorldBounds(x,y){\n    return !(x < 0 || y < 0 || x >= _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth || y >= _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight);\n}\n\nWorldMaker.prototype.addDecor = function(tile,decor){\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI(tile);\n    if(!(id in this.chunks)) return;\n    var chunk = this.chunks[id];\n    chunk.addDecor(tile.x-chunk.x,tile.y-chunk.y,decor);\n};\n\nWorldMaker.prototype.addResource = function(x,y,resource){\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI({x,y});\n    if(!(id in this.chunks)) return;\n    var chunk = this.chunks[id];\n    chunk.addResource(x-chunk.x,y-chunk.y,resource);\n};\n\n/*function removeTile(tile){\n    var id = Utils.tileToAOI(tile);\n    if(!(id in chunks)) return;\n    var chunk = chunks[id];\n    chunk.remove(tile.x-chunk.x,tile.y-chunk.y);\n}*/\n\nWorldMaker.prototype.addTile = function(tile,value){\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI(tile);\n    if(!(id in this.chunks)) return;\n    var chunk = this.chunks[id];\n    chunk.add(tile.x-chunk.x,tile.y-chunk.y,value);\n};\n\nWorldMaker.prototype.getTile = function(x,y){\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI({x:x,y:y});\n    if(!(id in this.chunks)) return;\n    var chunk = this.chunks[id];\n    return chunk.get(x-chunk.x,y-chunk.y);\n};\n\nWorldMaker.prototype.addCoastTiles = function(tiles){\n    var coast = [];\n    tiles.forEach(function(t) {\n        if(!isInWorldBounds(t.x,t.y)) return;\n        this.addTile(t,'c');\n        coast.push(t);\n    },this);\n    this.coasts.push(coast);\n};\n\nWorldMaker.prototype.collectPixels = function(){\n    this.greenpixels = [];\n    this.whitepixels = [];\n    var wm = this;\n    this.image.scan(0, 0, this.image.bitmap.width, this.image.bitmap.height, function (x, y, idx) {\n        //if(done) return;\n        // x, y is the position of this pixel on the image\n        // idx is the position start position of this rgba tuple in the bitmap Buffer\n        // this is the image\n\n        var red = this.bitmap.data[idx + 0];\n        var green = this.bitmap.data[idx + 1];\n        var blue = this.bitmap.data[idx + 2];\n\n        if(red == 203 && green == 230 && blue == 163) wm.greenpixels.push({x: x, y: y});\n        if(red == 255 && green == 255 && blue == 255) wm.whitepixels.push({x: x, y: y});\n\n        // Keep track of pixels that have also been mapped to land\n        // Due to space distortion, multiple pixels, black and white, can be mapped to the same tile!\n        if(red == 0 && green == 0 && blue == 0){\n            var g = wm.pixelToTile({x: x, y: y});\n            wm.land.add(g.x,g.y,1);\n        }\n    });\n}\n\nWorldMaker.prototype.pixelToTile = function(px){\n    return {\n        x: Math.round(px.x * (this.nbHoriz * this.chunkWidth / this.image.bitmap.width)),\n        y: Math.round(px.y * (this.nbVert * this.chunkHeight / this.image.bitmap.height))\n    };\n};\n\nWorldMaker.prototype.createLakes = function(){\n    console.log('Creating lakes ...');\n    // console.log(whitepixels.length,'white pixels');\n    var nblakes = 0;\n    for(var i = 0; i < this.whitepixels.length; i++){\n        var px = this.whitepixels[i];\n        var g = this.pixelToTile(px);\n        if(this.land.has(g.x,g.y)) continue;\n        var ok = true;\n        var contour = [[-1,0],[0,-1],[1,-1],[1,0],[0,1],[-1,1]];\n        for(var j = 0; j < contour.length; j++){\n            if(this.land.has(g.x+contour[j][0],g.y+contour[j][1]) || this.hasCoast(g.x+contour[j][0],g.y+contour[j][1])){\n                ok = false;\n                break;\n            }\n        }\n        if(ok){\n                var surface = this.fill(g);\n                if(surface > 100000) console.log(surface,px,g);\n                if (surface) nblakes++;\n        }\n    }\n    console.log(nblakes,'lakes created');\n};\n\nWorldMaker.prototype.canFill = function(node){\n    var t = this.getTile(node.x,node.y);\n    return !(t == 'c' || t == 'w');\n};\n\nWorldMaker.prototype.fill = function(fillNode,stop){ // fills the world with water, but stops at coastlines\n    // if(this.isBusy(fillNode)) return;\n    if(!this.canFill(fillNode)) return;\n    var stoppingCritetion = stop || 1000000;\n    var queue = [];\n    queue.push(fillNode);\n    var counter = 0;\n    var contour = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\n    while(queue.length > 0){\n        var node = queue.shift();\n        if(this.isBusy(node)) continue;\n        if(!this.canFill(node)) continue;\n        // put a tile at location\n        this.addTile(node,'w');\n        // this.collisions.add(node.x,node.y,1);\n        this.addCollision(node.x,node.y,'water');\n        this.mapPixels.add(node.x,node.y,'w');\n        // expand\n        for(var i = 0; i < contour.length; i++){\n            var candidate = {\n                x: node.x + contour[i][0],\n                y: node.y + contour[i][1]\n            };\n            if(!isInWorldBounds(candidate.x,candidate.y)) continue;\n            // if(!this.isBusy(candidate)) queue.push(candidate);\n            if(this.canFill(candidate)) queue.push(candidate);\n        }\n\n        counter++;\n        if(counter >= stoppingCritetion) break;\n    }\n    return counter;\n};\n\nWorldMaker.prototype.hasCoast = function(x,y){\n    if(!isInWorldBounds(x,y)) return true; // When looking for a neighbor out of bounds, assume it's present; allows seamless connections with borders\n    var t = this.getTile(x,y);\n    return !(!t || t == 'w');\n};\n\nWorldMaker.prototype.hasWater = function(x,y){\n    return this.getTile(x,y) == 'w';\n};\n\nWorldMaker.prototype.drawShore = function(){\n    console.log('Drawing shore ...');\n    //var tiles = ['wb', 'wbbl', 'wbbr', 'wbtl', 'wbtr', 'wcbl', 'wcbr', 'wctl', 'wctr', 'wl', 'wr', 'wt','none'];\n\n    var undef = 0;\n    this.coasts.forEach(function(coast){\n        coast.forEach(function(c){\n            var x = c.x;\n            var y = c.y;\n            var tile;\n            var nbrh = this.getNeighborhood(x,y);\n            tile = this.patterns[nbrh.join('')];\n            if(tile === undefined) {\n                console.log(x,y,nbrh.join(''));\n                undef++;\n            }\n\n            if(tile !== undefined && tile != 'none'){\n                this.addTile(c,tile); // Will replace any 'c'\n                // if(this.collides(tile)) this.collisions.add(x,y,1);\n                if(this.collides(tile)) this.addCollision(x,y,'shore');\n                this.mapPixels.add(x,y,'c');\n            }\n        },this);\n    },this);\n    console.log(undef,'undef');\n};\n\n// Create the string of ggccwccw ... or surrounding tiles used to determine current one\nWorldMaker.prototype.getNeighborhood = function(x,y){\n    var res = [];\n    var contour = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\n    for(var j = 0; j < contour.length; j++){\n        var v = 'g'; // -1\n        if(this.hasCoast(x+contour[j][0],y+contour[j][1])) v = 'c'; // 0\n        if(this.hasWater(x+contour[j][0],y+contour[j][1])) v = 'w'; // 1\n        res.push(v);\n    }\n    return res;\n};\n\nWorldMaker.prototype.collides = function(tile){\n    var longhand = this.tileset.shorthands[tile];\n    return this.tileset.frames[longhand].collides;\n};\n\nWorldMaker.prototype.createForests = function(){\n    console.log('Creating forests ...');\n    this.trees = new SpaceMap();\n    this.woodland = new SpaceMap();\n    if(this.treeSource){\n        this.restoreForest();\n        return;\n    }\n    var xRandRange = 7;\n    var yRandRange = 7;\n    var nbtrees = 0;\n    console.log(this.greenpixels.length,'green pixels');\n    for (var i = 0; i < this.greenpixels.length; i++) {\n        var px = this.greenpixels[i];\n        var g = this.pixelToTile(px);\n        g.x += _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(-xRandRange, xRandRange + 1);\n        g.y += _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(-yRandRange, yRandRange + 1);\n\n        var pos = this.checkPositions(g.x,g.y);\n        if(pos.length == 0) continue;\n\n        // TODO: move that up, to use tree type in positions computation\n        var type = getTreeType(g.x,g.y);\n        this.plantTree(g,pos,type);\n        nbtrees++;\n    }\n    console.log(nbtrees + ' trees planted');\n    if(this.notreesave) return;\n    fs.writeFile(path.join(__dirname,'blueprints','trees.json'),JSON.stringify(this.trees.toList()),function(err){\n        if(err) throw err;\n        console.log('Trees saved');\n    });\n};\n\nWorldMaker.prototype.plantTree = function(g,pos,type){\n    // g is {x,y} location\n    pos.forEach(function(p){\n        // this.collisions.add(p[0],p[1],1);\n        this.addCollision(p[0],p[1],'tree');\n    },this);\n    //TODO: adjust ranges / conf\n    for(var x = -4; x < 6; x++){\n        for(var y = -6; y < 5; y++){\n            this.woodland.add(parseInt(g.x)+x,parseInt(g.y)+y);\n            this.addResource(parseInt(g.x)+x,parseInt(g.y)+y,'wood');\n        }\n    }\n    this.trees.add(g.x,g.y,type);\n    this.addDecor(g, 't'+type);\n    this.addRandomItem(g.x,g.y,'tree');\n};\n\nWorldMaker.prototype.restoreForest = function(){\n    console.log('Restoring existing forest...');\n    var nbtrees = 0;\n    var trees = JSON.parse(fs.readFileSync(path.join('tools','blueprints','trees.json')).toString());\n    trees.forEach(function(t){\n        this.plantTree(t,this.checkPositions(t.x,t.y),t.v);\n        nbtrees++;\n    },this);\n    console.log(nbtrees + ' trees planted');\n};\n\nfunction getTreeType(x,y){\n    var poles = [Math.floor(_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight/2),_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight,0,Math.floor(_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight/4)]; // Pole for tree 1, 2, 3, 4 respectively\n    var dists = [];\n    var distsum = 0;\n    poles.forEach(function(p){\n        var d = Math.abs(y-p);\n        if(d == 0) d = 0.1;\n        d *= d; // Polarizes more\n        dists.push(d);\n        distsum += d;\n    });\n    var sumweights = 0;\n    var weights = dists.map(function(d){\n        var w = distsum/d;\n        sumweights += w;\n        return w;\n    });\n    var table = weights.map(function(w,i){\n        w = Math.round((w/sumweights)*10); // Normalization\n        if(w <= 2) w = 0;\n        return {weight: w, id: i+1};\n    });\n    var id = (_shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(1,101) <= 1 ? 'd' : rwc(table));\n    return id;\n}\n\nWorldMaker.prototype.checkPositions = function(x,y){\n    var free = true;\n    var xspan = 3; //TODO: conf\n    var yspan = 2;\n    var pos = [];\n    for(var xi = 0; xi < xspan; xi++){\n        for(var yi = 0; yi < yspan; yi++){\n            var rx = parseInt(x)+xi;\n            var ry = parseInt(y)-yi;\n            pos.push([rx,ry]);\n            if(this.isBusy({x:rx,y:ry})) free = false;\n            if(!free) break;\n        }\n        if(!free) break;\n    }\n    if(!free) return [];\n    return pos;\n};\n\nWorldMaker.prototype.addMisc = function(){\n    console.log('Adding misc ...');\n    var nbrocks = 5000; //TODO: conf\n    var nbadded = 0;\n    for(var i = 0; i < nbrocks; i++){\n        // console.log('zone');\n        var x = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth);\n        var y = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight);\n        if(!this.isBusy({x:x,y:y})) {\n            this.addCollision(x,y,'misc');\n            this.items.add(x,y,26);\n            nbadded++;\n        }\n    }\n    console.log(nbadded,' stones added');\n};\n\nWorldMaker.prototype.getAnimalData = function(type){\n    var animalData = this.animalsData[type];\n    if(animalData.inheritFrom !== undefined) animalData = Object.assign(this.animalsData[animalData.inheritFrom],animalData);\n    return animalData;\n};\n\nWorldMaker.prototype.makeSpawnZones = function(){\n    this.resourceMarkers = [];\n    for(var itemID in this.itemsData){\n        var itemData = this.itemsData[itemID];\n        if(!itemData.nbClusters) continue;\n        for(var i = 0; i < itemData.nbClusters; i++){\n            var x = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth-1);\n            var y = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight-1);\n            var w = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(5,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].chunkWidth);\n            var h = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(5,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].chunkHeight);\n            this.makeFloraZone(x,y,w,h,itemID,itemData);\n        }\n    }\n\n    for(var animalID in this.animalsData){\n        var animalData = this.getAnimalData(animalID);\n        for(var i = 0; i < animalData.nbPacks; i++){\n            var x = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth-1);\n                var y = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight-1);\n                if(!this.collisions.get(x,y)) this.makeAnimalZone(x,y,animalID);\n        }\n    }\n};\n\nWorldMaker.prototype.makeFloraZone = function(x,y,w,h,item,data){\n    var contour = [[0,-1],[0,0],[0,1],[1,1],[1,0],[2,0],[2,1],[2,-1]];\n    var nb = 0;\n    var nbbushes = data.nbBushes || 4;\n    // Look for trees inside the given area\n    for(var u = 0; u < w; u++){\n        for(var v = 0; v < h; v++){\n            var tree = this.trees.get(x+u,y+v);\n            if(tree){\n                _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shuffle(contour);\n                for(var j = 0; j < nbbushes; j++){\n                    var c = contour[j];\n                    var loc = {x:x+u+c[0],y:y+v+c[1]};\n                    if(data.decorFrame) this.addDecor(loc, data.decorFrame);\n                    this.items.add(loc.x,loc.y,item);\n                    nb++;\n                    // console.log('bush at',loc);\n                }\n            }\n        }\n    }\n    if(nb) this.resourceMarkers.push([Math.floor(x+w/2),Math.floor(y+h/2),item]);\n};\n\nWorldMaker.prototype.makeAnimalZone = function(x,y,type){\n    this.animals.add(x,y,type);\n    // this.animalsMarkers.push([x,y,type]);\n};\n\nWorldMaker.prototype.addRandomItem = function(x,y,decor){\n    var cnt = (decor == 'tree'\n        ? [[0,-1],[0,0],[0,1],[1,1],[1,0],[2,0],[2,1]]\n        : [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]]);\n    // var item = (decor == 'tree' ? 7 : 26); // wood or stone\n    var item = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomElement([7,7,7,30]); // wood or feathers TODO config\n    if(_shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(1,10) > 8){ // TODO: adjust\n        var c = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomElement(cnt);\n        var ix = parseInt(x)+c[0];\n        var iy = parseInt(y)+c[1];\n        this.items.add(ix,iy,item);\n        // console.log('adding',item,'at',ix,iy);\n    }\n};\n\nWorldMaker.prototype.writeDataFiles = function(){\n    // Write master file\n    var master = {\n        chunkWidth: this.chunkWidth,\n        chunkHeight: this.chunkHeight,\n        nbChunksHoriz: this.nbHoriz,\n        nbChunksVert: this.nbVert\n    };\n    fs.writeFile(path.join(this.outdir,'master.json'),JSON.stringify(master),function(err){\n        if(err) throw err;\n        console.log('Master written');\n    });\n    // Write collisions\n    var colls = this.collisions.toList(true);\n    fs.writeFile(path.join(this.outdir,'collisions.json'),JSON.stringify(colls),function(err){\n        if(err) throw err;\n        console.log('Collisions written');\n    });\n    fs.writeFile(path.join(this.outdir,'collisions_debug.json'),JSON.stringify(this.collisionsDebug.toList(true)),function(err){\n        if(err) throw err;\n        console.log('Collisions debug written');\n    });\n    // Write resources\n    fs.writeFile(path.join(this.outdir,'woodland.json'),JSON.stringify(this.woodland.toList(true)),function(err){\n        if(err) throw err;\n        console.log('Woodland written');\n    });\n    // Write resource & animals markers\n    fs.writeFile(path.join(this.outdir,'resourceMarkers.json'),JSON.stringify(this.resourceMarkers),function(err){\n        if(err) throw err;\n        console.log('Resource markers written');\n    });\n    // fs.writeFile(path.join(this.outdir,'animalMarkers.json'),JSON.stringify(this.animalsMarkers),function(err){\n    //     if(err) throw err;\n    //     console.log('Animal markers written');\n    // });\n    // Items\n    fs.writeFile(path.join(this.outdir,'items.json'),JSON.stringify(this.items.toList(true)),function(err){\n        if(err) throw err;\n        console.log('Items written');\n    });\n    // Animals\n    fs.writeFile(path.join(this.outdir,'animals.json'),JSON.stringify(this.animals.toList(true)),function(err){\n        if(err) throw err;\n        console.log('Animals written');\n    });\n};\n\nWorldMaker.prototype.makeWorldmap = function(){\n    var wm = this;\n    var hexes  = {     // last two characters: ff = visible, 00 = not\n        'c': 0x000000ff,\n        'w': 0x68b89fff,\n        'trunk': 0x7e5d2eff,\n        't1': 0x91a54aff,\n        't2': 0x9dbf48ff, //0x809c3bff,\n        't3': 0x7f9b75ff,\n        't4': 0x375b44ff,\n        // 'g': 0x809c3bff\n    };\n    new Jimp(_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth*2, _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight*2, 0xf9de99ff, function (err, image) { // 0x0,\n        wm.mapPixels.toList(true).forEach(function(px){\n            var x = px[0]*2;\n            var y = px[1]*2;\n            var color = hexes[px[2]];\n            image.setPixelColor(color, x, y);\n            image.setPixelColor(color, x+1, y);\n            image.setPixelColor(color, x, y+1);\n            image.setPixelColor(color, x+1, y+1);\n        });\n        wm.trees.toList(true).forEach(function(t){\n            var x = t[0]*2;\n            var y = t[1]*2;\n            for(var xi = 0; xi < 4; xi++){\n                for(var yi = 0; yi > -4; yi--){\n                    image.setPixelColor(hexes['trunk'], x+xi, y+yi);\n                }\n            }\n            if(t[2] == 'd') return;\n            x -= 2;\n            y -= 10;\n            for(var xi = 0; xi < 8; xi++){\n                for(var yi = 0; yi < 8; yi++){\n                    image.setPixelColor(hexes['t'+t[2]], x+xi, y+yi);\n                }\n            }\n        });\n        // image.write(path.join(wm.outdir,'worldmap.png'));\n        image = wm.medianBlur(image,'worldmap.png');\n    });\n};\n\nWorldMaker.prototype.medianBlur = function(image,name){\n    var wm = this;\n    var iw = image.bitmap.width*4; // because each \"px\"is 4 values\n    var ih = image.bitmap.height*4;\n    new Jimp(image.bitmap.width, image.bitmap.height, 0xf9de99ff, function (err, newimage) {\n        image.scan(0, 0, image.bitmap.width, image.bitmap.height, function (x, y, idx) {\n            if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\n                // image scan finished, do your stuff\n                newimage.write(path.join(wm.outdir,name));\n                return;\n              }\n            // idx is the position start position of this rgba tuple in the bitmap Buffer\n            var r = wm.colorMedian(iw,ih,this.bitmap.data,idx,0); //this.bitmap.data[idx + 0];\n            var g = wm.colorMedian(iw,ih,this.bitmap.data,idx,1); //this.bitmap.data[idx + 1];\n            var b = wm.colorMedian(iw,ih,this.bitmap.data,idx,2); // this.bitmap.data[idx + 2];\n            var a = this.bitmap.data[idx + 3];\n            // color = image.getPixelColor(x,y);\n            var color = Jimp.rgbaToInt(r, g, b, a);\n            newimage.setPixelColor(color, x,y);\n        });\n    });\n};\n\nWorldMaker.prototype.colorMedian = function(w,h,data,idx,offset){\n    var idcs = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].listNeighborsInGrid(idx,w,h,4);\n\n    var px = [];\n    idcs.forEach(function(i){\n        if(data[i+offset] != undefined) px.push(data[i+offset]);\n    });\n\n    var  l = px.length;\n    var n = (l%2 == 0 ? (l/2)-1 : (l-1)/2);\n    quickselect(px,n);\n    // console.log(w,h);\n    // console.log(idx)\n    // console.log(idcs)\n    // console.log(px)\n    // console.log('result:',px[n]);\n    return px[n];\n};\n\nvar args = __webpack_require__(/*! optimist */ \"optimist\").argv;\n\nvar wm = new WorldMaker(args);\nwm.run();\n\n\n//# sourceURL=webpack:///./tools/worldMaker.js?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "jimp":
/*!***********************!*\
  !*** external "jimp" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"jimp\");\n\n//# sourceURL=webpack:///external_%22jimp%22?");

/***/ }),

/***/ "optimist":
/*!***************************!*\
  !*** external "optimist" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"optimist\");\n\n//# sourceURL=webpack:///external_%22optimist%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "quickselect":
/*!******************************!*\
  !*** external "quickselect" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"quickselect\");\n\n//# sourceURL=webpack:///external_%22quickselect%22?");

/***/ }),

/***/ "random-weighted-choice":
/*!*****************************************!*\
  !*** external "random-weighted-choice" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"random-weighted-choice\");\n\n//# sourceURL=webpack:///external_%22random-weighted-choice%22?");

/***/ })

/******/ });